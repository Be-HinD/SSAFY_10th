### 이번 챕터의 목표
> 이상한 나라의 엘리스에 대한 이야기로 객체에 대해서 깊게 파고들기

<p> 현실세계의 주문과 계좌 이체는 비록 물리적인 실체는 존재하지 않더라도 인간이 쉽게 구분하고 하나의 단위로 인지할 수 있는 개념적인 객체의 일종 </p>

<br>

#### 객체지향 패러다임의 목적
> 현실 세계를 '모방'하는 것이 아닌 현실 세계를 기반으로 '새로운 세계'를 창조하는 것

> Why? 현실 세계의 전등은 스스로 불을 밝힐 수 없지만 소프트웨어 세계의 전등은 가능하다.

<br>

### 엘리스 객체
<p> 엘리스는 정원으로 가는 길을 막고 있는 작은 문을 통과하기 위해 자신의 키를 변경한다 </p>

> 또한 엘리스의 키는 시간의 흐름에 따라 계속 변한다
<p> 엘리스의 키를 변화시키는 것은 엘리스의 '행동' </p>

> '행동(음료 섭취 or 부채질)'에 따라 '상태(키)'가 변한다
<p> '행동'의 결과를 결정하는 것은 '상태'다 </p>

> 이전의 키에 따라 '행동'후의 키가 바뀐다 -> 행동의 결과는 상태에 '의존적'

<p> 엘리스는 키에 따라 문을 통과하여 정원으로 갈 수 있는지 여부가 정해진다 </p>

> 어떤 행동의 성공 여부는 이전에 어떤 행동들이 발생했는지에 영향을 받는다

<p> 엘리스가 문을 통과하기 전에 먼저 키를 작게 줄이기 위해 음료를 먹어야 한다 </p>

> 문을 통과하는 행동 이전에 음료를 먹는 행동을 먼저 해야한다
<p> 엘리스의 상태가 변경되더라도 전과 후는 모두 같은 엘리스다 </p>

> 엘리스의 상태 변경과 무관하게 유일한 존재로 식별 가능하다

<br>

#### 엘리스의 특징 요약
- 엘리스는 상태를 가지며 상태는 변경 가능하다
- 엘리스의 상태를 변경시키는 것은 엘리스의 행동이다
- 행동의 순서가 결과에 영향을 미친다
- 엘리스는 어떤 상태에 있더라도 유일하게 식별 가능하다

<br>

## 소프트웨어 객체
<p> 객체의 다양한 특성을 효과적으로 설명하기 위해서는 객체를 '상태', '행동', '식별자'를 지닌 실체로 보는 것이 효과적 </p>

### 상태(State)
<p> 비행기를 타려면 항공권을 발권해야 한다 </p>
<p> 엘리베이터가 움직이려면 원하는 층의 버튼을 눌러야 한다 </p>

> 이를 통해 어떤 행동의 결과는 과거에 어떤 행동들이 일어났냐에 의존한다는 것을 알 수 있음

<p> 상태를 이용하면 과거 행동 이력을 보지 않더라도 현재 행동의 결과를 예측할 수 있다 </p>
<p> 예로 비행기 탑승 가능 여부는 항공권의 발권 상태를 보고 예측할 수 있다 </p>

<br>

#### 상태와 프로퍼티
<p> 세상에 존재하는 모든 것들이 객체인 것은 아니다 </p>
<p> 엘리스의 '키'와 '위치'는 객체가 아닌 엘리스의 상태인 것 처럼 </p>
<p> 단순한 값들은 독립적(객체)이기 보다 객체의 특성을 표현하는 데 사용된다 </p>
<p> 그러나, 때때로 단순한 값이 아니라 객체를 사용해 다른 객체의 상태를 표현해야할 때가 있다 </p>

> 엘리스 객체가 음료 객체와 연결되어 있는지 여부로 판단할 수 있음

#### 결론적으로 모든 객체의 상태는 '단순한 값'과 '객체'의 조합으로 표현
<p> 엘리스의 특징을 나타내는 '키', '위치', '음료(객체)'는 프로퍼티라고 부른다 </p>

> 프로퍼티는 변경되지 않고 고정되기 때문에 '정적'이다 (변수명이라고 생각하면 될듯)

> 반면, 프로퍼티 값은 시간이 흐름에 따라 변경되기 때문에 '동적'이다 (변수값이라고 생각)

<p> 객체 간 참조는 '링크'라고 부른다 (엘리스와 음료 사이 연결) </p>

> 단순한 값인 '키'와 '위치'프로퍼티는 속성(attribute)으로 표현

> 음료라는 객체 프로퍼티는 링크로 표현

#### 상태와 프로퍼티를 코드로 이해
```java
public class Alice {
    int height; //엘리스의 키(속성 프로퍼티)
    int place; //엘리스의 현재 장소(속성 프로퍼티)
    DRINK drink; //엘리스의 음료 보유 여부(링크)
}

class DRINK {
    
}
```

<br>

### 행동(Behavior)
<p> 앞서 객체는 자율적인 존재이며, 다른 객체의 상태에 접근, 변경이 불가하다는 것을 봤음 </p>

> 객체는 스스로의 행동에 의해서만 상태가 변경됨을 보장해야 자율성을 유지한다
<p> 이 말은 엘리스의 객체가 음료 객체의 상태에 접근조차 안됨을 의미 </p>
<p> 그럼 어떻게 객체 간의 상호작용이 가능할까? </p>

#### 협력과 행동
<p> 객체가 다른 객체와 협력하는 유일한 방법은 '요청'을 보내는 것 </p>

> '요청'을 통해 객체는 자신의 상태뿐만 아니라 다른 객체의 상태 변경을 '유발'할 수도 있다
<p> 객체의 행동의 결과는 두가지인걸 알 수 있다 </p>

- 객체 자신의 상태 변경
- 협력 객체에 대한 메시지 전송

#### 상태 캡슐화
<p> 음료는 엘리스가 마시는 행동을 통해 양이 줄어들 수 있다 </p>

> 엘리스는 음료에게 '요청'을 보내야한다
<p> 엘리스 객체는 '요청'으로 음료 객체의 상태 변경을 예상할 수 있을까? </p>

> 결론적으로 엘리스는 음료의 상태 변경을 알 수 없다 -> <b> "캡슐화" </b>
<p> 캡슐화는 상태를 외부에 숨기고, 행동을 통해서만 노출하는 것을 의미한다 </p>
<p> 캡슐화를 통해 객체 스스로 판단하고 결정하게 함으로써 객체의 자율성을 높이고 협력을 단순하게 유연하게 만든다 </p>

> '상태'를 '캡슐화'해야 하는 이유는 자율성을 보장하기위해

#### 나만의 정의!
<p> A객체는 B객체의 상태에 직접적으로 접근할 수 없게 만들고 행동을 통해서만 접근하게 하는 것이 "캡슐화" </p>
<p> 캡슐화가 자율성을 높이는 이유는 B객체는 A객체가 직접적으로 변경하지 못한다. 요청을 받더라도 스스로가 판단하여 상태를 변경하기 때문에 B객체는 상태를 잘 캡슐화 함으로써 협력은 가능하되 자율성은 높아진다. </p>
<p> 어떻게 캡슐화 할거야? </p>

> private 접근 제한자를 통한 상태 숨기기

> Getter와 Setter 행동을 통해 요청만 받을 수 있도록 노출

<br>

### 식별자(Identity)
<p> 객체는 프로퍼티로 단순한 값(변수), 다른 객체를 가질 수 있음 </p>
<p> int 42는 언제나 42다. 다시 말하면 변수의 값 자체는 바뀔 수 있지만 42 -> 32, 42가 바뀌진 않는다는 것이다. 이를 불변상태라고 말한다 </p>
<p> 반면에 객체는 가변 상태를 가진다. 타입이 같은 두 객체의 상태가 완전히 똑같더라도 두 객체는 독립적인 별개의 객체이다. 왜? 식별자때문에 </p>
<p> 쉽게 말하면 객체 동등 비교를 떠올리면 된다. 동등 비교를 진행하려면 equals()와 hashCode()를 재정의해야 하듯 프로퍼티가 같아도 다른 객체다. </p>

> 정리하자면 객체는 불변 상태인 단순한 값, 가변 상태인 다른 객체를 가질 수 있다

> 또한 객체의 경우 가변 상태이기 때문에 식별자를 통해 상태가 같아도 다른 객체로 인식할 수 있다

<br>

## 행동이 상태를 결정한다.
<p> 나는 객체에 필요한 상태가 무엇인지를 결정하고 그 상태에 필요한 행동을 결정하고 있었다 </p>
<p> 그런 이러한 방법은 설계에 나쁜 영향을 끼칠 수 있다 </p>

- 캡슐화가 저해된다
- 협력관계에 적합하지 못한 객체를 만든다
- 객체의 재사용성이 저하된다

<p> 이러한 이유로 앞으로는 상태가 아닌 행동에 초점을 맞춰야 한다 </p>

### 객체지향의 오해
<p> 객체지향 애플리케이션이 현실의 구조를 정확하게 반영해야 한다는 것은 "오해"다 </p>
<p> 소프트웨어 세상의 객체를 현실의 구조로 "은유" 표현할 뿐 </p>

> 객체지향 지침서에서는 은유를 통해 현실 세계 도메인에서 사용되는 이름을 객체에 부여하라고 가이드 하고있다.

